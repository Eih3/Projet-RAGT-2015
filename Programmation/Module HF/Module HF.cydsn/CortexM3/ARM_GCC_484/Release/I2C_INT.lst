ARM GAS  C:\Users\Eih3\AppData\Local\Temp\cc1gG7hm.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"I2C_INT.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.I2C_ISR,"ax",%progbits
  19              		.align	1
  20              		.global	I2C_ISR
  21              		.thumb
  22              		.thumb_func
  23              		.type	I2C_ISR, %function
  24              	I2C_ISR:
  25              	.LFB0:
  26              		.file 1 ".\\Generated_Source\\PSoC5\\I2C_INT.c"
   1:.\Generated_Source\PSoC5/I2C_INT.c **** /*******************************************************************************
   2:.\Generated_Source\PSoC5/I2C_INT.c **** * File Name: I2C_INT.c
   3:.\Generated_Source\PSoC5/I2C_INT.c **** * Version 3.40
   4:.\Generated_Source\PSoC5/I2C_INT.c **** *
   5:.\Generated_Source\PSoC5/I2C_INT.c **** * Description:
   6:.\Generated_Source\PSoC5/I2C_INT.c **** *  This file provides the source code of Interrupt Service Routine (ISR)
   7:.\Generated_Source\PSoC5/I2C_INT.c **** *  for the I2C component.
   8:.\Generated_Source\PSoC5/I2C_INT.c **** *
   9:.\Generated_Source\PSoC5/I2C_INT.c **** ********************************************************************************
  10:.\Generated_Source\PSoC5/I2C_INT.c **** * Copyright 2008-2015, Cypress Semiconductor Corporation. All rights reserved.
  11:.\Generated_Source\PSoC5/I2C_INT.c **** * You may use this file only in accordance with the license, terms, conditions,
  12:.\Generated_Source\PSoC5/I2C_INT.c **** * disclaimers, and limitations in the end user license agreement accompanying
  13:.\Generated_Source\PSoC5/I2C_INT.c **** * the software package with which this file was provided.
  14:.\Generated_Source\PSoC5/I2C_INT.c **** *******************************************************************************/
  15:.\Generated_Source\PSoC5/I2C_INT.c **** 
  16:.\Generated_Source\PSoC5/I2C_INT.c **** #include "I2C_PVT.h"
  17:.\Generated_Source\PSoC5/I2C_INT.c **** 
  18:.\Generated_Source\PSoC5/I2C_INT.c **** 
  19:.\Generated_Source\PSoC5/I2C_INT.c **** /*******************************************************************************
  20:.\Generated_Source\PSoC5/I2C_INT.c **** *  Place your includes, defines and code here.
  21:.\Generated_Source\PSoC5/I2C_INT.c **** ********************************************************************************/
  22:.\Generated_Source\PSoC5/I2C_INT.c **** /* `#START I2C_ISR_intc` */
  23:.\Generated_Source\PSoC5/I2C_INT.c **** 
  24:.\Generated_Source\PSoC5/I2C_INT.c **** /* `#END` */
  25:.\Generated_Source\PSoC5/I2C_INT.c **** 
  26:.\Generated_Source\PSoC5/I2C_INT.c **** 
  27:.\Generated_Source\PSoC5/I2C_INT.c **** /*******************************************************************************
  28:.\Generated_Source\PSoC5/I2C_INT.c **** * Function Name: I2C_ISR
  29:.\Generated_Source\PSoC5/I2C_INT.c **** ********************************************************************************
  30:.\Generated_Source\PSoC5/I2C_INT.c **** *
  31:.\Generated_Source\PSoC5/I2C_INT.c **** * Summary:
ARM GAS  C:\Users\Eih3\AppData\Local\Temp\cc1gG7hm.s 			page 2


  32:.\Generated_Source\PSoC5/I2C_INT.c **** *  The handler for the I2C interrupt. The slave and master operations are
  33:.\Generated_Source\PSoC5/I2C_INT.c **** *  handled here.
  34:.\Generated_Source\PSoC5/I2C_INT.c **** *
  35:.\Generated_Source\PSoC5/I2C_INT.c **** * Parameters:
  36:.\Generated_Source\PSoC5/I2C_INT.c **** *  None.
  37:.\Generated_Source\PSoC5/I2C_INT.c **** *
  38:.\Generated_Source\PSoC5/I2C_INT.c **** * Return:
  39:.\Generated_Source\PSoC5/I2C_INT.c **** *  None.
  40:.\Generated_Source\PSoC5/I2C_INT.c **** *
  41:.\Generated_Source\PSoC5/I2C_INT.c **** * Reentrant:
  42:.\Generated_Source\PSoC5/I2C_INT.c **** *  No.
  43:.\Generated_Source\PSoC5/I2C_INT.c **** *
  44:.\Generated_Source\PSoC5/I2C_INT.c **** *******************************************************************************/
  45:.\Generated_Source\PSoC5/I2C_INT.c **** CY_ISR(I2C_ISR)
  46:.\Generated_Source\PSoC5/I2C_INT.c **** {
  27              		.loc 1 46 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31 0000 70B5     		push	{r4, r5, r6, lr}
  32              		.cfi_def_cfa_offset 16
  33              		.cfi_offset 4, -16
  34              		.cfi_offset 5, -12
  35              		.cfi_offset 6, -8
  36              		.cfi_offset 14, -4
  47:.\Generated_Source\PSoC5/I2C_INT.c **** #if (I2C_MODE_SLAVE_ENABLED)
  48:.\Generated_Source\PSoC5/I2C_INT.c ****    uint8  tmp8;
  49:.\Generated_Source\PSoC5/I2C_INT.c **** #endif  /* (I2C_MODE_SLAVE_ENABLED) */
  50:.\Generated_Source\PSoC5/I2C_INT.c **** 
  51:.\Generated_Source\PSoC5/I2C_INT.c ****     uint8  tmpCsr;
  52:.\Generated_Source\PSoC5/I2C_INT.c **** 
  53:.\Generated_Source\PSoC5/I2C_INT.c **** #if(I2C_TIMEOUT_FF_ENABLED)
  54:.\Generated_Source\PSoC5/I2C_INT.c ****     if(0u != I2C_TimeoutGetStatus())
  55:.\Generated_Source\PSoC5/I2C_INT.c ****     {
  56:.\Generated_Source\PSoC5/I2C_INT.c ****         I2C_TimeoutReset();
  57:.\Generated_Source\PSoC5/I2C_INT.c ****         I2C_state = I2C_SM_EXIT_IDLE;
  58:.\Generated_Source\PSoC5/I2C_INT.c ****         /* I2C_CSR_REG should be cleared after reset */
  59:.\Generated_Source\PSoC5/I2C_INT.c ****     }
  60:.\Generated_Source\PSoC5/I2C_INT.c **** #endif /* (I2C_TIMEOUT_FF_ENABLED) */
  61:.\Generated_Source\PSoC5/I2C_INT.c **** 
  62:.\Generated_Source\PSoC5/I2C_INT.c **** 
  63:.\Generated_Source\PSoC5/I2C_INT.c ****     tmpCsr = I2C_CSR_REG;      /* Make copy as interrupts clear */
  64:.\Generated_Source\PSoC5/I2C_INT.c **** 
  65:.\Generated_Source\PSoC5/I2C_INT.c **** #if(I2C_MODE_MULTI_MASTER_SLAVE_ENABLED)
  66:.\Generated_Source\PSoC5/I2C_INT.c ****     if(I2C_CHECK_START_GEN(I2C_MCSR_REG))
  67:.\Generated_Source\PSoC5/I2C_INT.c ****     {
  68:.\Generated_Source\PSoC5/I2C_INT.c ****         I2C_CLEAR_START_GEN;
  69:.\Generated_Source\PSoC5/I2C_INT.c **** 
  70:.\Generated_Source\PSoC5/I2C_INT.c ****         /* Set transfer complete and error flags */
  71:.\Generated_Source\PSoC5/I2C_INT.c ****         I2C_mstrStatus |= (I2C_MSTAT_ERR_XFER |
  72:.\Generated_Source\PSoC5/I2C_INT.c ****                                         I2C_GET_MSTAT_CMPLT);
  73:.\Generated_Source\PSoC5/I2C_INT.c **** 
  74:.\Generated_Source\PSoC5/I2C_INT.c ****         /* Slave was addressed */
  75:.\Generated_Source\PSoC5/I2C_INT.c ****         I2C_state = I2C_SM_SLAVE;
  76:.\Generated_Source\PSoC5/I2C_INT.c ****     }
  77:.\Generated_Source\PSoC5/I2C_INT.c **** #endif /* (I2C_MODE_MULTI_MASTER_SLAVE_ENABLED) */
  78:.\Generated_Source\PSoC5/I2C_INT.c **** 
ARM GAS  C:\Users\Eih3\AppData\Local\Temp\cc1gG7hm.s 			page 3


  79:.\Generated_Source\PSoC5/I2C_INT.c **** 
  80:.\Generated_Source\PSoC5/I2C_INT.c **** #if(I2C_MODE_MULTI_MASTER_ENABLED)
  81:.\Generated_Source\PSoC5/I2C_INT.c ****     if(I2C_CHECK_LOST_ARB(tmpCsr))
  82:.\Generated_Source\PSoC5/I2C_INT.c ****     {
  83:.\Generated_Source\PSoC5/I2C_INT.c ****         /* Set errors */
  84:.\Generated_Source\PSoC5/I2C_INT.c ****         I2C_mstrStatus |= (I2C_MSTAT_ERR_XFER     |
  85:.\Generated_Source\PSoC5/I2C_INT.c ****                                         I2C_MSTAT_ERR_ARB_LOST |
  86:.\Generated_Source\PSoC5/I2C_INT.c ****                                         I2C_GET_MSTAT_CMPLT);
  87:.\Generated_Source\PSoC5/I2C_INT.c **** 
  88:.\Generated_Source\PSoC5/I2C_INT.c ****         I2C_DISABLE_INT_ON_STOP; /* Interrupt on Stop is enabled by write */
  89:.\Generated_Source\PSoC5/I2C_INT.c **** 
  90:.\Generated_Source\PSoC5/I2C_INT.c ****         #if(I2C_MODE_MULTI_MASTER_SLAVE_ENABLED)
  91:.\Generated_Source\PSoC5/I2C_INT.c ****             if(I2C_CHECK_ADDRESS_STS(tmpCsr))
  92:.\Generated_Source\PSoC5/I2C_INT.c ****             {
  93:.\Generated_Source\PSoC5/I2C_INT.c ****                 /* Slave was addressed */
  94:.\Generated_Source\PSoC5/I2C_INT.c ****                 I2C_state = I2C_SM_SLAVE;
  95:.\Generated_Source\PSoC5/I2C_INT.c ****             }
  96:.\Generated_Source\PSoC5/I2C_INT.c ****             else
  97:.\Generated_Source\PSoC5/I2C_INT.c ****             {
  98:.\Generated_Source\PSoC5/I2C_INT.c ****                 I2C_BUS_RELEASE;
  99:.\Generated_Source\PSoC5/I2C_INT.c **** 
 100:.\Generated_Source\PSoC5/I2C_INT.c ****                 I2C_state = I2C_SM_EXIT_IDLE;
 101:.\Generated_Source\PSoC5/I2C_INT.c ****             }
 102:.\Generated_Source\PSoC5/I2C_INT.c ****         #else
 103:.\Generated_Source\PSoC5/I2C_INT.c ****             I2C_BUS_RELEASE;
 104:.\Generated_Source\PSoC5/I2C_INT.c **** 
 105:.\Generated_Source\PSoC5/I2C_INT.c ****             I2C_state = I2C_SM_EXIT_IDLE;
 106:.\Generated_Source\PSoC5/I2C_INT.c **** 
 107:.\Generated_Source\PSoC5/I2C_INT.c ****         #endif /* (I2C_MODE_MULTI_MASTER_SLAVE_ENABLED) */
 108:.\Generated_Source\PSoC5/I2C_INT.c ****     }
 109:.\Generated_Source\PSoC5/I2C_INT.c **** #endif /* (I2C_MODE_MULTI_MASTER_ENABLED) */
 110:.\Generated_Source\PSoC5/I2C_INT.c **** 
 111:.\Generated_Source\PSoC5/I2C_INT.c ****     /* Check for master operation mode */
 112:.\Generated_Source\PSoC5/I2C_INT.c ****     if(I2C_CHECK_SM_MASTER)
  37              		.loc 1 112 0
  38 0002 7B48     		ldr	r0, .L37
  63:.\Generated_Source\PSoC5/I2C_INT.c ****     tmpCsr = I2C_CSR_REG;      /* Make copy as interrupts clear */
  39              		.loc 1 63 0
  40 0004 7B49     		ldr	r1, .L37+4
  41 0006 0B78     		ldrb	r3, [r1]	@ zero_extendqisi2
  42              		.loc 1 112 0
  43 0008 0278     		ldrb	r2, [r0]	@ zero_extendqisi2
  63:.\Generated_Source\PSoC5/I2C_INT.c ****     tmpCsr = I2C_CSR_REG;      /* Make copy as interrupts clear */
  44              		.loc 1 63 0
  45 000a DBB2     		uxtb	r3, r3
  46              	.LVL0:
  47              		.loc 1 112 0
  48 000c 12F0400F 		tst	r2, #64
  49 0010 0246     		mov	r2, r0
  50 0012 00F0E680 		beq	.L2
 113:.\Generated_Source\PSoC5/I2C_INT.c ****     {
 114:.\Generated_Source\PSoC5/I2C_INT.c ****     #if(I2C_MODE_MASTER_ENABLED)
 115:.\Generated_Source\PSoC5/I2C_INT.c ****         if(I2C_CHECK_BYTE_COMPLETE(tmpCsr))
  51              		.loc 1 115 0
  52 0016 D807     		lsls	r0, r3, #31
  53 0018 40F1CF80 		bpl	.L3
 116:.\Generated_Source\PSoC5/I2C_INT.c ****         {
ARM GAS  C:\Users\Eih3\AppData\Local\Temp\cc1gG7hm.s 			page 4


 117:.\Generated_Source\PSoC5/I2C_INT.c ****             switch (I2C_state)
  54              		.loc 1 117 0
  55 001c 1078     		ldrb	r0, [r2]	@ zero_extendqisi2
  56 001e 4538     		subs	r0, r0, #69
  57 0020 0528     		cmp	r0, #5
  58 0022 00F2CA80 		bhi	.L3
  59 0026 DFE810F0 		tbh	[pc, r0, lsl #1]
  60              	.L5:
  61 002a 0600     		.2byte	(.L4-.L5)/2
  62 002c 5700     		.2byte	(.L6-.L5)/2
  63 002e C800     		.2byte	(.L3-.L5)/2
  64 0030 C800     		.2byte	(.L3-.L5)/2
  65 0032 0600     		.2byte	(.L4-.L5)/2
  66 0034 9800     		.2byte	(.L7-.L5)/2
  67              		.p2align 1
  68              	.L4:
 118:.\Generated_Source\PSoC5/I2C_INT.c ****             {
 119:.\Generated_Source\PSoC5/I2C_INT.c ****             case I2C_SM_MSTR_WR_ADDR:  /* After address is sent, write data */
 120:.\Generated_Source\PSoC5/I2C_INT.c ****             case I2C_SM_MSTR_RD_ADDR:  /* After address is sent, read data */
 121:.\Generated_Source\PSoC5/I2C_INT.c **** 
 122:.\Generated_Source\PSoC5/I2C_INT.c ****                 tmpCsr &= ((uint8) ~I2C_CSR_STOP_STATUS); /* Clear Stop bit history on address phas
  69              		.loc 1 122 0
  70 0036 03F0DF00 		and	r0, r3, #223
  71              	.LVL1:
 123:.\Generated_Source\PSoC5/I2C_INT.c **** 
 124:.\Generated_Source\PSoC5/I2C_INT.c ****                 if(I2C_CHECK_ADDR_ACK(tmpCsr))
  72              		.loc 1 124 0
  73 003a 03F00A03 		and	r3, r3, #10
  74 003e 082B     		cmp	r3, #8
  75 0040 24D1     		bne	.L8
 125:.\Generated_Source\PSoC5/I2C_INT.c ****                 {
 126:.\Generated_Source\PSoC5/I2C_INT.c ****                     /* Setup for transmit or receive of data */
 127:.\Generated_Source\PSoC5/I2C_INT.c ****                     if(I2C_state == I2C_SM_MSTR_WR_ADDR)   /* TRANSMIT data */
  76              		.loc 1 127 0
  77 0042 1478     		ldrb	r4, [r2]	@ zero_extendqisi2
  78 0044 6A4B     		ldr	r3, .L37
  79 0046 452C     		cmp	r4, #69
  80 0048 1BD1     		bne	.L9
 128:.\Generated_Source\PSoC5/I2C_INT.c ****                     {
 129:.\Generated_Source\PSoC5/I2C_INT.c ****                         /* Check if at least one byte to transfer */
 130:.\Generated_Source\PSoC5/I2C_INT.c ****                         if(I2C_mstrWrBufSize > 0u)
  81              		.loc 1 130 0
  82 004a 6B4C     		ldr	r4, .L37+8
  83 004c 2478     		ldrb	r4, [r4]	@ zero_extendqisi2
  84 004e 64B1     		cbz	r4, .L10
 131:.\Generated_Source\PSoC5/I2C_INT.c ****                         {
 132:.\Generated_Source\PSoC5/I2C_INT.c ****                             /* Load the 1st data byte */
 133:.\Generated_Source\PSoC5/I2C_INT.c ****                             I2C_DATA_REG = I2C_mstrWrBufPtr[0u];
  85              		.loc 1 133 0
  86 0050 6A4C     		ldr	r4, .L37+12
  87 0052 2468     		ldr	r4, [r4]
  88 0054 2578     		ldrb	r5, [r4]	@ zero_extendqisi2
  89 0056 6A4C     		ldr	r4, .L37+16
  90 0058 EDB2     		uxtb	r5, r5
  91 005a 2570     		strb	r5, [r4]
 134:.\Generated_Source\PSoC5/I2C_INT.c ****                             I2C_TRANSMIT_DATA;
  92              		.loc 1 134 0
ARM GAS  C:\Users\Eih3\AppData\Local\Temp\cc1gG7hm.s 			page 5


  93 005c 0424     		movs	r4, #4
  94 005e 0C70     		strb	r4, [r1]
 135:.\Generated_Source\PSoC5/I2C_INT.c ****                             I2C_mstrWrBufIndex = 1u;   /* Set index to 2nd element */
  95              		.loc 1 135 0
  96 0060 6849     		ldr	r1, .L37+20
  97 0062 0124     		movs	r4, #1
  98 0064 0C70     		strb	r4, [r1]
 136:.\Generated_Source\PSoC5/I2C_INT.c **** 
 137:.\Generated_Source\PSoC5/I2C_INT.c ****                             /* Set transmit state until done */
 138:.\Generated_Source\PSoC5/I2C_INT.c ****                             I2C_state = I2C_SM_MSTR_WR_DATA;
  99              		.loc 1 138 0
 100 0066 4621     		movs	r1, #70
 101 0068 0EE0     		b	.L35
 102              	.L10:
 139:.\Generated_Source\PSoC5/I2C_INT.c ****                         }
 140:.\Generated_Source\PSoC5/I2C_INT.c ****                         /* End of buffer: complete writing */
 141:.\Generated_Source\PSoC5/I2C_INT.c ****                         else if(I2C_CHECK_NO_STOP(I2C_mstrControl))
 103              		.loc 1 141 0
 104 006a 674C     		ldr	r4, .L37+24
 105 006c 2478     		ldrb	r4, [r4]	@ zero_extendqisi2
 106 006e A607     		lsls	r6, r4, #30
 107 0070 28D5     		bpl	.L12
 142:.\Generated_Source\PSoC5/I2C_INT.c ****                         {
 143:.\Generated_Source\PSoC5/I2C_INT.c ****                             /* Set write complete and master halted */
 144:.\Generated_Source\PSoC5/I2C_INT.c ****                             I2C_mstrStatus |= (I2C_MSTAT_XFER_HALT |
 108              		.loc 1 144 0
 109 0072 6649     		ldr	r1, .L37+28
 110 0074 0C78     		ldrb	r4, [r1]	@ zero_extendqisi2
 111 0076 44F00A04 		orr	r4, r4, #10
 112 007a 0C70     		strb	r4, [r1]
 145:.\Generated_Source\PSoC5/I2C_INT.c ****                                                             I2C_MSTAT_WR_CMPLT);
 146:.\Generated_Source\PSoC5/I2C_INT.c **** 
 147:.\Generated_Source\PSoC5/I2C_INT.c ****                             I2C_state = I2C_SM_MSTR_HALT; /* Expect ReStart */
 113              		.loc 1 147 0
 114 007c 6021     		movs	r1, #96
 115 007e 1970     		strb	r1, [r3]
 116 0080 1BE0     		b	.L34
 117              	.L9:
 148:.\Generated_Source\PSoC5/I2C_INT.c ****                             I2C_DisableInt();
 149:.\Generated_Source\PSoC5/I2C_INT.c ****                         }
 150:.\Generated_Source\PSoC5/I2C_INT.c ****                         else
 151:.\Generated_Source\PSoC5/I2C_INT.c ****                         {
 152:.\Generated_Source\PSoC5/I2C_INT.c ****                             I2C_ENABLE_INT_ON_STOP; /* Enable interrupt on Stop, to catch it */
 153:.\Generated_Source\PSoC5/I2C_INT.c ****                             I2C_GENERATE_STOP;
 154:.\Generated_Source\PSoC5/I2C_INT.c ****                         }
 155:.\Generated_Source\PSoC5/I2C_INT.c ****                     }
 156:.\Generated_Source\PSoC5/I2C_INT.c ****                     else  /* Master receive data */
 157:.\Generated_Source\PSoC5/I2C_INT.c ****                     {
 158:.\Generated_Source\PSoC5/I2C_INT.c ****                         I2C_READY_TO_READ; /* Release bus to read data */
 118              		.loc 1 158 0
 119 0082 0024     		movs	r4, #0
 120 0084 0C70     		strb	r4, [r1]
 159:.\Generated_Source\PSoC5/I2C_INT.c **** 
 160:.\Generated_Source\PSoC5/I2C_INT.c ****                         I2C_state  = I2C_SM_MSTR_RD_DATA;
 121              		.loc 1 160 0
 122 0086 4A21     		movs	r1, #74
 123              	.L35:
ARM GAS  C:\Users\Eih3\AppData\Local\Temp\cc1gG7hm.s 			page 6


 124 0088 1970     		strb	r1, [r3]
 125 008a 95E0     		b	.L24
 126              	.L8:
 161:.\Generated_Source\PSoC5/I2C_INT.c ****                     }
 162:.\Generated_Source\PSoC5/I2C_INT.c ****                 }
 163:.\Generated_Source\PSoC5/I2C_INT.c ****                 /* Address is NACKed */
 164:.\Generated_Source\PSoC5/I2C_INT.c ****                 else if(I2C_CHECK_ADDR_NAK(tmpCsr))
 127              		.loc 1 164 0
 128 008c 0A2B     		cmp	r3, #10
 129 008e 40F09380 		bne	.L24
 165:.\Generated_Source\PSoC5/I2C_INT.c ****                 {
 166:.\Generated_Source\PSoC5/I2C_INT.c ****                     /* Set Address NAK error */
 167:.\Generated_Source\PSoC5/I2C_INT.c ****                     I2C_mstrStatus |= (I2C_MSTAT_ERR_XFER |
 130              		.loc 1 167 0
 131 0092 5E4B     		ldr	r3, .L37+28
 132 0094 1C78     		ldrb	r4, [r3]	@ zero_extendqisi2
 133 0096 44F0A004 		orr	r4, r4, #160
 134 009a 1C70     		strb	r4, [r3]
 168:.\Generated_Source\PSoC5/I2C_INT.c ****                                                     I2C_MSTAT_ERR_ADDR_NAK);
 169:.\Generated_Source\PSoC5/I2C_INT.c **** 
 170:.\Generated_Source\PSoC5/I2C_INT.c ****                     if(I2C_CHECK_NO_STOP(I2C_mstrControl))
 135              		.loc 1 170 0
 136 009c 5A4C     		ldr	r4, .L37+24
 137 009e 2478     		ldrb	r4, [r4]	@ zero_extendqisi2
 138 00a0 A507     		lsls	r5, r4, #30
 139 00a2 0FD5     		bpl	.L12
 171:.\Generated_Source\PSoC5/I2C_INT.c ****                     {
 172:.\Generated_Source\PSoC5/I2C_INT.c ****                         I2C_mstrStatus |= (I2C_MSTAT_XFER_HALT |
 140              		.loc 1 172 0
 141 00a4 1978     		ldrb	r1, [r3]	@ zero_extendqisi2
 173:.\Generated_Source\PSoC5/I2C_INT.c ****                                                         I2C_GET_MSTAT_CMPLT);
 142              		.loc 1 173 0
 143 00a6 1478     		ldrb	r4, [r2]	@ zero_extendqisi2
 172:.\Generated_Source\PSoC5/I2C_INT.c ****                         I2C_mstrStatus |= (I2C_MSTAT_XFER_HALT |
 144              		.loc 1 172 0
 145 00a8 14F0080F 		tst	r4, #8
 146 00ac 0CBF     		ite	eq
 147 00ae 0A24     		moveq	r4, #10
 148 00b0 0924     		movne	r4, #9
 149 00b2 2143     		orrs	r1, r1, r4
 150 00b4 1970     		strb	r1, [r3]
 174:.\Generated_Source\PSoC5/I2C_INT.c **** 
 175:.\Generated_Source\PSoC5/I2C_INT.c ****                         I2C_state = I2C_SM_MSTR_HALT; /* Expect RESTART */
 151              		.loc 1 175 0
 152 00b6 6023     		movs	r3, #96
 153 00b8 1370     		strb	r3, [r2]
 154              	.L34:
 176:.\Generated_Source\PSoC5/I2C_INT.c ****                         I2C_DisableInt();
 155              		.loc 1 176 0
 156 00ba 554B     		ldr	r3, .L37+32
 157 00bc 4FF40041 		mov	r1, #32768
 158 00c0 1960     		str	r1, [r3]
 159 00c2 79E0     		b	.L24
 160              	.L12:
 177:.\Generated_Source\PSoC5/I2C_INT.c ****                     }
 178:.\Generated_Source\PSoC5/I2C_INT.c ****                     else  /* Do normal Stop */
 179:.\Generated_Source\PSoC5/I2C_INT.c ****                     {
ARM GAS  C:\Users\Eih3\AppData\Local\Temp\cc1gG7hm.s 			page 7


 180:.\Generated_Source\PSoC5/I2C_INT.c ****                         I2C_ENABLE_INT_ON_STOP; /* Enable interrupt on Stop, to catch it */
 161              		.loc 1 180 0
 162 00c4 534B     		ldr	r3, .L37+36
 163 00c6 1C78     		ldrb	r4, [r3]	@ zero_extendqisi2
 164 00c8 44F01004 		orr	r4, r4, #16
 165 00cc 1C70     		strb	r4, [r3]
 181:.\Generated_Source\PSoC5/I2C_INT.c ****                         I2C_GENERATE_STOP;
 166              		.loc 1 181 0
 167 00ce 1024     		movs	r4, #16
 168 00d0 DC70     		strb	r4, [r3, #3]
 169 00d2 0423     		movs	r3, #4
 170 00d4 0B70     		strb	r3, [r1]
 171 00d6 6FE0     		b	.L24
 172              	.LVL2:
 173              	.L6:
 182:.\Generated_Source\PSoC5/I2C_INT.c ****                     }
 183:.\Generated_Source\PSoC5/I2C_INT.c ****                 }
 184:.\Generated_Source\PSoC5/I2C_INT.c ****                 else
 185:.\Generated_Source\PSoC5/I2C_INT.c ****                 {
 186:.\Generated_Source\PSoC5/I2C_INT.c ****                     /* Address phase is not set for some reason: error */
 187:.\Generated_Source\PSoC5/I2C_INT.c ****                     #if(I2C_TIMEOUT_ENABLED)
 188:.\Generated_Source\PSoC5/I2C_INT.c ****                         /* Exit interrupt to take chance for timeout timer to handle this case */
 189:.\Generated_Source\PSoC5/I2C_INT.c ****                         I2C_DisableInt();
 190:.\Generated_Source\PSoC5/I2C_INT.c ****                         I2C_ClearPendingInt();
 191:.\Generated_Source\PSoC5/I2C_INT.c ****                     #else
 192:.\Generated_Source\PSoC5/I2C_INT.c ****                         /* Block execution flow: unexpected condition */
 193:.\Generated_Source\PSoC5/I2C_INT.c ****                         CYASSERT(0u != 0u);
 194:.\Generated_Source\PSoC5/I2C_INT.c ****                     #endif /* (I2C_TIMEOUT_ENABLED) */
 195:.\Generated_Source\PSoC5/I2C_INT.c ****                 }
 196:.\Generated_Source\PSoC5/I2C_INT.c ****                 break;
 197:.\Generated_Source\PSoC5/I2C_INT.c **** 
 198:.\Generated_Source\PSoC5/I2C_INT.c ****             case I2C_SM_MSTR_WR_DATA:
 199:.\Generated_Source\PSoC5/I2C_INT.c **** 
 200:.\Generated_Source\PSoC5/I2C_INT.c ****                 if(I2C_CHECK_DATA_ACK(tmpCsr))
 174              		.loc 1 200 0
 175 00d8 9C07     		lsls	r4, r3, #30
 176 00da 25D4     		bmi	.L14
 201:.\Generated_Source\PSoC5/I2C_INT.c ****                 {
 202:.\Generated_Source\PSoC5/I2C_INT.c ****                     /* Check if end of buffer */
 203:.\Generated_Source\PSoC5/I2C_INT.c ****                     if(I2C_mstrWrBufIndex  < I2C_mstrWrBufSize)
 177              		.loc 1 203 0
 178 00dc 4948     		ldr	r0, .L37+20
 179 00de 464C     		ldr	r4, .L37+8
 180 00e0 0578     		ldrb	r5, [r0]	@ zero_extendqisi2
 181 00e2 2478     		ldrb	r4, [r4]	@ zero_extendqisi2
 182 00e4 A542     		cmp	r5, r4
 183 00e6 0DD2     		bcs	.L15
 204:.\Generated_Source\PSoC5/I2C_INT.c ****                     {
 205:.\Generated_Source\PSoC5/I2C_INT.c ****                         I2C_DATA_REG =
 206:.\Generated_Source\PSoC5/I2C_INT.c ****                                                  I2C_mstrWrBufPtr[I2C_mstrWrBufIndex];
 184              		.loc 1 206 0
 185 00e8 444D     		ldr	r5, .L37+12
 186 00ea 0478     		ldrb	r4, [r0]	@ zero_extendqisi2
 187 00ec 2D68     		ldr	r5, [r5]
 188 00ee E4B2     		uxtb	r4, r4
 189 00f0 2D5D     		ldrb	r5, [r5, r4]	@ zero_extendqisi2
 205:.\Generated_Source\PSoC5/I2C_INT.c ****                         I2C_DATA_REG =
ARM GAS  C:\Users\Eih3\AppData\Local\Temp\cc1gG7hm.s 			page 8


 190              		.loc 1 205 0
 191 00f2 434C     		ldr	r4, .L37+16
 192              		.loc 1 206 0
 193 00f4 EDB2     		uxtb	r5, r5
 205:.\Generated_Source\PSoC5/I2C_INT.c ****                         I2C_DATA_REG =
 194              		.loc 1 205 0
 195 00f6 2570     		strb	r5, [r4]
 207:.\Generated_Source\PSoC5/I2C_INT.c ****                         I2C_TRANSMIT_DATA;
 196              		.loc 1 207 0
 197 00f8 0424     		movs	r4, #4
 198 00fa 0C70     		strb	r4, [r1]
 208:.\Generated_Source\PSoC5/I2C_INT.c ****                         I2C_mstrWrBufIndex++;
 199              		.loc 1 208 0
 200 00fc 0178     		ldrb	r1, [r0]	@ zero_extendqisi2
 201 00fe 0131     		adds	r1, r1, #1
 202 0100 C9B2     		uxtb	r1, r1
 203 0102 28E0     		b	.L33
 204              	.L15:
 209:.\Generated_Source\PSoC5/I2C_INT.c ****                     }
 210:.\Generated_Source\PSoC5/I2C_INT.c ****                     /* End of buffer: complete writing */
 211:.\Generated_Source\PSoC5/I2C_INT.c ****                     else if(I2C_CHECK_NO_STOP(I2C_mstrControl))
 205              		.loc 1 211 0
 206 0104 4048     		ldr	r0, .L37+24
 207 0106 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 208 0108 8007     		lsls	r0, r0, #30
 209 010a 04D5     		bpl	.L16
 212:.\Generated_Source\PSoC5/I2C_INT.c ****                     {
 213:.\Generated_Source\PSoC5/I2C_INT.c ****                         /* Set write complete and master halted */
 214:.\Generated_Source\PSoC5/I2C_INT.c ****                         I2C_mstrStatus |= (I2C_MSTAT_XFER_HALT |
 210              		.loc 1 214 0
 211 010c 3F49     		ldr	r1, .L37+28
 212 010e 0878     		ldrb	r0, [r1]	@ zero_extendqisi2
 213 0110 40F00A00 		orr	r0, r0, #10
 214 0114 41E0     		b	.L32
 215              	.L16:
 215:.\Generated_Source\PSoC5/I2C_INT.c ****                                                         I2C_MSTAT_WR_CMPLT);
 216:.\Generated_Source\PSoC5/I2C_INT.c **** 
 217:.\Generated_Source\PSoC5/I2C_INT.c ****                         I2C_state = I2C_SM_MSTR_HALT;    /* Expect restart */
 218:.\Generated_Source\PSoC5/I2C_INT.c ****                         I2C_DisableInt();
 219:.\Generated_Source\PSoC5/I2C_INT.c ****                     }
 220:.\Generated_Source\PSoC5/I2C_INT.c ****                     else  /* Do normal Stop */
 221:.\Generated_Source\PSoC5/I2C_INT.c ****                     {
 222:.\Generated_Source\PSoC5/I2C_INT.c ****                         I2C_ENABLE_INT_ON_STOP;    /* Enable interrupt on Stop, to catch it */
 216              		.loc 1 222 0
 217 0116 3F48     		ldr	r0, .L37+36
 218 0118 0478     		ldrb	r4, [r0]	@ zero_extendqisi2
 219 011a 44F01004 		orr	r4, r4, #16
 220 011e 0470     		strb	r4, [r0]
 223:.\Generated_Source\PSoC5/I2C_INT.c ****                         I2C_GENERATE_STOP;
 221              		.loc 1 223 0
 222 0120 1024     		movs	r4, #16
 223 0122 C470     		strb	r4, [r0, #3]
 224 0124 0420     		movs	r0, #4
 225 0126 2BE0     		b	.L30
 226              	.L14:
 224:.\Generated_Source\PSoC5/I2C_INT.c ****                     }
 225:.\Generated_Source\PSoC5/I2C_INT.c ****                 }
ARM GAS  C:\Users\Eih3\AppData\Local\Temp\cc1gG7hm.s 			page 9


 226:.\Generated_Source\PSoC5/I2C_INT.c ****                 /* Last byte NAKed: end writing */
 227:.\Generated_Source\PSoC5/I2C_INT.c ****                 else if(I2C_CHECK_NO_STOP(I2C_mstrControl))
 227              		.loc 1 227 0
 228 0128 3748     		ldr	r0, .L37+24
 229 012a 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 230 012c 10F0020F 		tst	r0, #2
 231 0130 3648     		ldr	r0, .L37+28
 232 0132 04D0     		beq	.L17
 228:.\Generated_Source\PSoC5/I2C_INT.c ****                 {
 229:.\Generated_Source\PSoC5/I2C_INT.c ****                     /* Set write complete, short transfer and master halted */
 230:.\Generated_Source\PSoC5/I2C_INT.c ****                     I2C_mstrStatus |= (I2C_MSTAT_ERR_XFER       |
 233              		.loc 1 230 0
 234 0134 0178     		ldrb	r1, [r0]	@ zero_extendqisi2
 235 0136 41F09A01 		orr	r1, r1, #154
 236 013a 0170     		strb	r1, [r0]
 237 013c 2EE0     		b	.L31
 238              	.L17:
 231:.\Generated_Source\PSoC5/I2C_INT.c ****                                                     I2C_MSTAT_ERR_SHORT_XFER |
 232:.\Generated_Source\PSoC5/I2C_INT.c ****                                                     I2C_MSTAT_XFER_HALT      |
 233:.\Generated_Source\PSoC5/I2C_INT.c ****                                                     I2C_MSTAT_WR_CMPLT);
 234:.\Generated_Source\PSoC5/I2C_INT.c **** 
 235:.\Generated_Source\PSoC5/I2C_INT.c ****                     I2C_state = I2C_SM_MSTR_HALT;    /* Expect ReStart */
 236:.\Generated_Source\PSoC5/I2C_INT.c ****                     I2C_DisableInt();
 237:.\Generated_Source\PSoC5/I2C_INT.c ****                 }
 238:.\Generated_Source\PSoC5/I2C_INT.c ****                 else  /* Do normal Stop */
 239:.\Generated_Source\PSoC5/I2C_INT.c ****                 {
 240:.\Generated_Source\PSoC5/I2C_INT.c ****                     I2C_ENABLE_INT_ON_STOP;    /* Enable interrupt on Stop, to catch it */
 239              		.loc 1 240 0
 240 013e 354C     		ldr	r4, .L37+36
 241 0140 2578     		ldrb	r5, [r4]	@ zero_extendqisi2
 242 0142 45F01005 		orr	r5, r5, #16
 243 0146 2570     		strb	r5, [r4]
 241:.\Generated_Source\PSoC5/I2C_INT.c ****                     I2C_GENERATE_STOP;
 244              		.loc 1 241 0
 245 0148 1025     		movs	r5, #16
 246 014a E570     		strb	r5, [r4, #3]
 247 014c 0424     		movs	r4, #4
 248 014e 0C70     		strb	r4, [r1]
 242:.\Generated_Source\PSoC5/I2C_INT.c **** 
 243:.\Generated_Source\PSoC5/I2C_INT.c ****                     /* Set short transfer and error flag */
 244:.\Generated_Source\PSoC5/I2C_INT.c ****                     I2C_mstrStatus |= (I2C_MSTAT_ERR_SHORT_XFER |
 249              		.loc 1 244 0
 250 0150 0178     		ldrb	r1, [r0]	@ zero_extendqisi2
 251 0152 41F09001 		orr	r1, r1, #144
 252              	.L33:
 253 0156 0170     		strb	r1, [r0]
 254 0158 2FE0     		b	.L3
 255              	.L7:
 245:.\Generated_Source\PSoC5/I2C_INT.c ****                                                     I2C_MSTAT_ERR_XFER);
 246:.\Generated_Source\PSoC5/I2C_INT.c ****                 }
 247:.\Generated_Source\PSoC5/I2C_INT.c **** 
 248:.\Generated_Source\PSoC5/I2C_INT.c ****                 break;
 249:.\Generated_Source\PSoC5/I2C_INT.c **** 
 250:.\Generated_Source\PSoC5/I2C_INT.c ****             case I2C_SM_MSTR_RD_DATA:
 251:.\Generated_Source\PSoC5/I2C_INT.c **** 
 252:.\Generated_Source\PSoC5/I2C_INT.c ****                 I2C_mstrRdBufPtr[I2C_mstrRdBufIndex] = I2C_DATA_REG;
 256              		.loc 1 252 0
ARM GAS  C:\Users\Eih3\AppData\Local\Temp\cc1gG7hm.s 			page 10


 257 015a 2F48     		ldr	r0, .L37+40
 258 015c 284E     		ldr	r6, .L37+16
 259 015e 2F4D     		ldr	r5, .L37+44
 260 0160 0478     		ldrb	r4, [r0]	@ zero_extendqisi2
 261 0162 3678     		ldrb	r6, [r6]	@ zero_extendqisi2
 262 0164 2D68     		ldr	r5, [r5]
 263 0166 E4B2     		uxtb	r4, r4
 264 0168 F6B2     		uxtb	r6, r6
 265 016a 2E55     		strb	r6, [r5, r4]
 253:.\Generated_Source\PSoC5/I2C_INT.c ****                 I2C_mstrRdBufIndex++;
 266              		.loc 1 253 0
 267 016c 0478     		ldrb	r4, [r0]	@ zero_extendqisi2
 268 016e 0134     		adds	r4, r4, #1
 269 0170 E4B2     		uxtb	r4, r4
 270 0172 0470     		strb	r4, [r0]
 254:.\Generated_Source\PSoC5/I2C_INT.c **** 
 255:.\Generated_Source\PSoC5/I2C_INT.c ****                 /* Check if end of buffer */
 256:.\Generated_Source\PSoC5/I2C_INT.c ****                 if(I2C_mstrRdBufIndex < I2C_mstrRdBufSize)
 271              		.loc 1 256 0
 272 0174 0478     		ldrb	r4, [r0]	@ zero_extendqisi2
 273 0176 2A48     		ldr	r0, .L37+48
 274 0178 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 275 017a 8442     		cmp	r4, r0
 276 017c 02D2     		bcs	.L18
 257:.\Generated_Source\PSoC5/I2C_INT.c ****                 {
 258:.\Generated_Source\PSoC5/I2C_INT.c ****                     I2C_ACK_AND_RECEIVE;       /* ACK and receive byte */
 277              		.loc 1 258 0
 278 017e 1020     		movs	r0, #16
 279              	.L30:
 280 0180 0870     		strb	r0, [r1]
 281 0182 1AE0     		b	.L3
 282              	.L18:
 259:.\Generated_Source\PSoC5/I2C_INT.c ****                 }
 260:.\Generated_Source\PSoC5/I2C_INT.c ****                 /* End of buffer: complete reading */
 261:.\Generated_Source\PSoC5/I2C_INT.c ****                 else if(I2C_CHECK_NO_STOP(I2C_mstrControl))
 283              		.loc 1 261 0
 284 0184 2048     		ldr	r0, .L37+24
 285 0186 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 286 0188 00F00200 		and	r0, r0, #2
 287 018c 00F0FF04 		and	r4, r0, #255
 288 0190 58B1     		cbz	r0, .L19
 262:.\Generated_Source\PSoC5/I2C_INT.c ****                 {
 263:.\Generated_Source\PSoC5/I2C_INT.c ****                     /* Set read complete and master halted */
 264:.\Generated_Source\PSoC5/I2C_INT.c ****                     I2C_mstrStatus |= (I2C_MSTAT_XFER_HALT |
 289              		.loc 1 264 0
 290 0192 1E49     		ldr	r1, .L37+28
 291 0194 0878     		ldrb	r0, [r1]	@ zero_extendqisi2
 292 0196 40F00900 		orr	r0, r0, #9
 293              	.L32:
 294 019a 0870     		strb	r0, [r1]
 295              	.L31:
 265:.\Generated_Source\PSoC5/I2C_INT.c ****                                                     I2C_MSTAT_RD_CMPLT);
 266:.\Generated_Source\PSoC5/I2C_INT.c **** 
 267:.\Generated_Source\PSoC5/I2C_INT.c ****                     I2C_state = I2C_SM_MSTR_HALT;    /* Expect ReStart */
 296              		.loc 1 267 0
 297 019c 6021     		movs	r1, #96
 298 019e 1170     		strb	r1, [r2]
ARM GAS  C:\Users\Eih3\AppData\Local\Temp\cc1gG7hm.s 			page 11


 268:.\Generated_Source\PSoC5/I2C_INT.c ****                     I2C_DisableInt();
 299              		.loc 1 268 0
 300 01a0 1B49     		ldr	r1, .L37+32
 301 01a2 4FF40040 		mov	r0, #32768
 302 01a6 0860     		str	r0, [r1]
 303 01a8 07E0     		b	.L3
 304              	.L19:
 269:.\Generated_Source\PSoC5/I2C_INT.c ****                 }
 270:.\Generated_Source\PSoC5/I2C_INT.c ****                 else
 271:.\Generated_Source\PSoC5/I2C_INT.c ****                 {
 272:.\Generated_Source\PSoC5/I2C_INT.c ****                     I2C_ENABLE_INT_ON_STOP;
 305              		.loc 1 272 0
 306 01aa 1A48     		ldr	r0, .L37+36
 307 01ac 0578     		ldrb	r5, [r0]	@ zero_extendqisi2
 308 01ae 45F01005 		orr	r5, r5, #16
 309 01b2 0570     		strb	r5, [r0]
 273:.\Generated_Source\PSoC5/I2C_INT.c ****                     I2C_NAK_AND_RECEIVE;       /* NACK and TRY to generate Stop */
 310              		.loc 1 273 0
 311 01b4 0C70     		strb	r4, [r1]
 312 01b6 00E0     		b	.L3
 313              	.LVL3:
 314              	.L24:
 122:.\Generated_Source\PSoC5/I2C_INT.c ****                 tmpCsr &= ((uint8) ~I2C_CSR_STOP_STATUS); /* Clear Stop bit history on address phas
 315              		.loc 1 122 0
 316 01b8 0346     		mov	r3, r0
 317              	.LVL4:
 318              	.L3:
 274:.\Generated_Source\PSoC5/I2C_INT.c ****                 }
 275:.\Generated_Source\PSoC5/I2C_INT.c ****                 break;
 276:.\Generated_Source\PSoC5/I2C_INT.c **** 
 277:.\Generated_Source\PSoC5/I2C_INT.c ****             default: /* This is an invalid state and should not occur */
 278:.\Generated_Source\PSoC5/I2C_INT.c **** 
 279:.\Generated_Source\PSoC5/I2C_INT.c ****             #if(I2C_TIMEOUT_ENABLED)
 280:.\Generated_Source\PSoC5/I2C_INT.c ****                 /* Exit interrupt to take chance for timeout timer to handles this case */
 281:.\Generated_Source\PSoC5/I2C_INT.c ****                 I2C_DisableInt();
 282:.\Generated_Source\PSoC5/I2C_INT.c ****                 I2C_ClearPendingInt();
 283:.\Generated_Source\PSoC5/I2C_INT.c ****             #else
 284:.\Generated_Source\PSoC5/I2C_INT.c ****                 /* Block execution flow: unexpected condition */
 285:.\Generated_Source\PSoC5/I2C_INT.c ****                 CYASSERT(0u != 0u);
 286:.\Generated_Source\PSoC5/I2C_INT.c ****             #endif /* (I2C_TIMEOUT_ENABLED) */
 287:.\Generated_Source\PSoC5/I2C_INT.c **** 
 288:.\Generated_Source\PSoC5/I2C_INT.c ****                 break;
 289:.\Generated_Source\PSoC5/I2C_INT.c ****             }
 290:.\Generated_Source\PSoC5/I2C_INT.c ****         }
 291:.\Generated_Source\PSoC5/I2C_INT.c **** 
 292:.\Generated_Source\PSoC5/I2C_INT.c ****         /* Catches Stop: end of transaction */
 293:.\Generated_Source\PSoC5/I2C_INT.c ****         if(I2C_CHECK_STOP_STS(tmpCsr))
 319              		.loc 1 293 0
 320 01ba 9906     		lsls	r1, r3, #26
 321 01bc 16D5     		bpl	.L1
 294:.\Generated_Source\PSoC5/I2C_INT.c ****         {
 295:.\Generated_Source\PSoC5/I2C_INT.c ****             I2C_mstrStatus |= I2C_GET_MSTAT_CMPLT;
 322              		.loc 1 295 0
 323 01be 134B     		ldr	r3, .L37+28
 324              	.LVL5:
 325 01c0 1978     		ldrb	r1, [r3]	@ zero_extendqisi2
 326 01c2 1078     		ldrb	r0, [r2]	@ zero_extendqisi2
ARM GAS  C:\Users\Eih3\AppData\Local\Temp\cc1gG7hm.s 			page 12


 327 01c4 10F0080F 		tst	r0, #8
 328 01c8 0CBF     		ite	eq
 329 01ca 0220     		moveq	r0, #2
 330 01cc 0120     		movne	r0, #1
 331 01ce 0143     		orrs	r1, r1, r0
 332 01d0 1970     		strb	r1, [r3]
 296:.\Generated_Source\PSoC5/I2C_INT.c **** 
 297:.\Generated_Source\PSoC5/I2C_INT.c ****             I2C_DISABLE_INT_ON_STOP;
 333              		.loc 1 297 0
 334 01d2 104B     		ldr	r3, .L37+36
 335 01d4 1978     		ldrb	r1, [r3]	@ zero_extendqisi2
 336 01d6 01F0EF01 		and	r1, r1, #239
 337 01da 1970     		strb	r1, [r3]
 298:.\Generated_Source\PSoC5/I2C_INT.c ****             I2C_state = I2C_SM_IDLE;
 338              		.loc 1 298 0
 339 01dc 1023     		movs	r3, #16
 340 01de 1370     		strb	r3, [r2]
 341 01e0 70BD     		pop	{r4, r5, r6, pc}
 342              	.LVL6:
 343              	.L2:
 299:.\Generated_Source\PSoC5/I2C_INT.c ****         }
 300:.\Generated_Source\PSoC5/I2C_INT.c ****     #endif /* (I2C_MODE_MASTER_ENABLED) */
 301:.\Generated_Source\PSoC5/I2C_INT.c ****     }
 302:.\Generated_Source\PSoC5/I2C_INT.c ****     else if(I2C_CHECK_SM_SLAVE)
 344              		.loc 1 302 0
 345 01e2 0378     		ldrb	r3, [r0]	@ zero_extendqisi2
 346              	.LVL7:
 347 01e4 DB06     		lsls	r3, r3, #27
 303:.\Generated_Source\PSoC5/I2C_INT.c ****     {
 304:.\Generated_Source\PSoC5/I2C_INT.c ****     #if(I2C_MODE_SLAVE_ENABLED)
 305:.\Generated_Source\PSoC5/I2C_INT.c **** 
 306:.\Generated_Source\PSoC5/I2C_INT.c ****         if((I2C_CHECK_STOP_STS(tmpCsr)) || /* Stop || Restart */
 307:.\Generated_Source\PSoC5/I2C_INT.c ****            (I2C_CHECK_BYTE_COMPLETE(tmpCsr) && I2C_CHECK_ADDRESS_STS(tmpCsr)))
 308:.\Generated_Source\PSoC5/I2C_INT.c ****         {
 309:.\Generated_Source\PSoC5/I2C_INT.c ****             /* Catch end of master write transaction: use interrupt on Stop */
 310:.\Generated_Source\PSoC5/I2C_INT.c ****             /* The Stop bit history on address phase does not have correct state */
 311:.\Generated_Source\PSoC5/I2C_INT.c ****             if(I2C_SM_SL_WR_DATA == I2C_state)
 312:.\Generated_Source\PSoC5/I2C_INT.c ****             {
 313:.\Generated_Source\PSoC5/I2C_INT.c ****                 I2C_DISABLE_INT_ON_STOP;
 314:.\Generated_Source\PSoC5/I2C_INT.c **** 
 315:.\Generated_Source\PSoC5/I2C_INT.c ****                 I2C_slStatus &= ((uint8) ~I2C_SSTAT_WR_BUSY);
 316:.\Generated_Source\PSoC5/I2C_INT.c ****                 I2C_slStatus |= ((uint8)  I2C_SSTAT_WR_CMPLT);
 317:.\Generated_Source\PSoC5/I2C_INT.c **** 
 318:.\Generated_Source\PSoC5/I2C_INT.c ****                 I2C_state = I2C_SM_IDLE;
 319:.\Generated_Source\PSoC5/I2C_INT.c ****             }
 320:.\Generated_Source\PSoC5/I2C_INT.c ****         }
 321:.\Generated_Source\PSoC5/I2C_INT.c **** 
 322:.\Generated_Source\PSoC5/I2C_INT.c ****         if(I2C_CHECK_BYTE_COMPLETE(tmpCsr))
 323:.\Generated_Source\PSoC5/I2C_INT.c ****         {
 324:.\Generated_Source\PSoC5/I2C_INT.c ****             /* The address only issued after Start or ReStart: so check the address
 325:.\Generated_Source\PSoC5/I2C_INT.c ****                to catch these events:
 326:.\Generated_Source\PSoC5/I2C_INT.c ****                 FF : sets an address phase with a byte_complete interrupt trigger.
 327:.\Generated_Source\PSoC5/I2C_INT.c ****                 UDB: sets an address phase immediately after Start or ReStart. */
 328:.\Generated_Source\PSoC5/I2C_INT.c ****             if(I2C_CHECK_ADDRESS_STS(tmpCsr))
 329:.\Generated_Source\PSoC5/I2C_INT.c ****             {
 330:.\Generated_Source\PSoC5/I2C_INT.c ****             /* Check for software address detection */
 331:.\Generated_Source\PSoC5/I2C_INT.c ****             #if(I2C_SW_ADRR_DECODE)
ARM GAS  C:\Users\Eih3\AppData\Local\Temp\cc1gG7hm.s 			page 13


 332:.\Generated_Source\PSoC5/I2C_INT.c ****                 tmp8 = I2C_GET_SLAVE_ADDR(I2C_DATA_REG);
 333:.\Generated_Source\PSoC5/I2C_INT.c **** 
 334:.\Generated_Source\PSoC5/I2C_INT.c ****                 if(tmp8 == I2C_slAddress)   /* Check for address match */
 335:.\Generated_Source\PSoC5/I2C_INT.c ****                 {
 336:.\Generated_Source\PSoC5/I2C_INT.c ****                     if(0u != (I2C_DATA_REG & I2C_READ_FLAG))
 337:.\Generated_Source\PSoC5/I2C_INT.c ****                     {
 338:.\Generated_Source\PSoC5/I2C_INT.c ****                         /* Place code to prepare read buffer here                  */
 339:.\Generated_Source\PSoC5/I2C_INT.c ****                         /* `#START I2C_SW_PREPARE_READ_BUF_interrupt` */
 340:.\Generated_Source\PSoC5/I2C_INT.c **** 
 341:.\Generated_Source\PSoC5/I2C_INT.c ****                         /* `#END` */
 342:.\Generated_Source\PSoC5/I2C_INT.c **** 
 343:.\Generated_Source\PSoC5/I2C_INT.c ****                         /* Prepare next operation to read, get data and place in data register */
 344:.\Generated_Source\PSoC5/I2C_INT.c ****                         if(I2C_slRdBufIndex < I2C_slRdBufSize)
 345:.\Generated_Source\PSoC5/I2C_INT.c ****                         {
 346:.\Generated_Source\PSoC5/I2C_INT.c ****                             /* Load first data byte from array */
 347:.\Generated_Source\PSoC5/I2C_INT.c ****                             I2C_DATA_REG = I2C_slRdBufPtr[I2C_slRdBufIndex];
 348:.\Generated_Source\PSoC5/I2C_INT.c ****                             I2C_ACK_AND_TRANSMIT;
 349:.\Generated_Source\PSoC5/I2C_INT.c ****                             I2C_slRdBufIndex++;
 350:.\Generated_Source\PSoC5/I2C_INT.c **** 
 351:.\Generated_Source\PSoC5/I2C_INT.c ****                             I2C_slStatus |= I2C_SSTAT_RD_BUSY;
 352:.\Generated_Source\PSoC5/I2C_INT.c ****                         }
 353:.\Generated_Source\PSoC5/I2C_INT.c ****                         else    /* Overflow: provide 0xFF on bus */
 354:.\Generated_Source\PSoC5/I2C_INT.c ****                         {
 355:.\Generated_Source\PSoC5/I2C_INT.c ****                             I2C_DATA_REG = I2C_OVERFLOW_RETURN;
 356:.\Generated_Source\PSoC5/I2C_INT.c ****                             I2C_ACK_AND_TRANSMIT;
 357:.\Generated_Source\PSoC5/I2C_INT.c **** 
 358:.\Generated_Source\PSoC5/I2C_INT.c ****                             I2C_slStatus  |= (I2C_SSTAT_RD_BUSY |
 359:.\Generated_Source\PSoC5/I2C_INT.c ****                                                            I2C_SSTAT_RD_ERR_OVFL);
 360:.\Generated_Source\PSoC5/I2C_INT.c ****                         }
 361:.\Generated_Source\PSoC5/I2C_INT.c **** 
 362:.\Generated_Source\PSoC5/I2C_INT.c ****                         I2C_state = I2C_SM_SL_RD_DATA;
 363:.\Generated_Source\PSoC5/I2C_INT.c ****                     }
 364:.\Generated_Source\PSoC5/I2C_INT.c ****                     else  /* Write transaction: receive 1st byte */
 365:.\Generated_Source\PSoC5/I2C_INT.c ****                     {
 366:.\Generated_Source\PSoC5/I2C_INT.c ****                         I2C_ACK_AND_RECEIVE;
 367:.\Generated_Source\PSoC5/I2C_INT.c ****                         I2C_state = I2C_SM_SL_WR_DATA;
 368:.\Generated_Source\PSoC5/I2C_INT.c **** 
 369:.\Generated_Source\PSoC5/I2C_INT.c ****                         I2C_slStatus |= I2C_SSTAT_WR_BUSY;
 370:.\Generated_Source\PSoC5/I2C_INT.c ****                         I2C_ENABLE_INT_ON_STOP;
 371:.\Generated_Source\PSoC5/I2C_INT.c ****                     }
 372:.\Generated_Source\PSoC5/I2C_INT.c ****                 }
 373:.\Generated_Source\PSoC5/I2C_INT.c ****                 else
 374:.\Generated_Source\PSoC5/I2C_INT.c ****                 {
 375:.\Generated_Source\PSoC5/I2C_INT.c ****                     /*     Place code to compare for additional address here    */
 376:.\Generated_Source\PSoC5/I2C_INT.c ****                     /* `#START I2C_SW_ADDR_COMPARE_interruptStart` */
 377:.\Generated_Source\PSoC5/I2C_INT.c **** 
 378:.\Generated_Source\PSoC5/I2C_INT.c ****                     /* `#END` */
 379:.\Generated_Source\PSoC5/I2C_INT.c **** 
 380:.\Generated_Source\PSoC5/I2C_INT.c ****                     I2C_NAK_AND_RECEIVE;   /* NACK address */
 381:.\Generated_Source\PSoC5/I2C_INT.c **** 
 382:.\Generated_Source\PSoC5/I2C_INT.c ****                     /* Place code to end of condition for NACK generation here */
 383:.\Generated_Source\PSoC5/I2C_INT.c ****                     /* `#START I2C_SW_ADDR_COMPARE_interruptEnd`  */
 384:.\Generated_Source\PSoC5/I2C_INT.c **** 
 385:.\Generated_Source\PSoC5/I2C_INT.c ****                     /* `#END` */
 386:.\Generated_Source\PSoC5/I2C_INT.c ****                 }
 387:.\Generated_Source\PSoC5/I2C_INT.c **** 
 388:.\Generated_Source\PSoC5/I2C_INT.c ****             #else /* (I2C_HW_ADRR_DECODE) */
ARM GAS  C:\Users\Eih3\AppData\Local\Temp\cc1gG7hm.s 			page 14


 389:.\Generated_Source\PSoC5/I2C_INT.c **** 
 390:.\Generated_Source\PSoC5/I2C_INT.c ****                 if(0u != (I2C_DATA_REG & I2C_READ_FLAG))
 391:.\Generated_Source\PSoC5/I2C_INT.c ****                 {
 392:.\Generated_Source\PSoC5/I2C_INT.c ****                     /* Place code to prepare read buffer here                  */
 393:.\Generated_Source\PSoC5/I2C_INT.c ****                     /* `#START I2C_HW_PREPARE_READ_BUF_interrupt` */
 394:.\Generated_Source\PSoC5/I2C_INT.c **** 
 395:.\Generated_Source\PSoC5/I2C_INT.c ****                     /* `#END` */
 396:.\Generated_Source\PSoC5/I2C_INT.c **** 
 397:.\Generated_Source\PSoC5/I2C_INT.c ****                     /* Prepare next operation to read, get data and place in data register */
 398:.\Generated_Source\PSoC5/I2C_INT.c ****                     if(I2C_slRdBufIndex < I2C_slRdBufSize)
 399:.\Generated_Source\PSoC5/I2C_INT.c ****                     {
 400:.\Generated_Source\PSoC5/I2C_INT.c ****                         /* Load first data byte from array */
 401:.\Generated_Source\PSoC5/I2C_INT.c ****                         I2C_DATA_REG = I2C_slRdBufPtr[I2C_slRdBufIndex];
 402:.\Generated_Source\PSoC5/I2C_INT.c ****                         I2C_ACK_AND_TRANSMIT;
 403:.\Generated_Source\PSoC5/I2C_INT.c ****                         I2C_slRdBufIndex++;
 404:.\Generated_Source\PSoC5/I2C_INT.c **** 
 405:.\Generated_Source\PSoC5/I2C_INT.c ****                         I2C_slStatus |= I2C_SSTAT_RD_BUSY;
 406:.\Generated_Source\PSoC5/I2C_INT.c ****                     }
 407:.\Generated_Source\PSoC5/I2C_INT.c ****                     else    /* Overflow: provide 0xFF on bus */
 408:.\Generated_Source\PSoC5/I2C_INT.c ****                     {
 409:.\Generated_Source\PSoC5/I2C_INT.c ****                         I2C_DATA_REG = I2C_OVERFLOW_RETURN;
 410:.\Generated_Source\PSoC5/I2C_INT.c ****                         I2C_ACK_AND_TRANSMIT;
 411:.\Generated_Source\PSoC5/I2C_INT.c **** 
 412:.\Generated_Source\PSoC5/I2C_INT.c ****                         I2C_slStatus  |= (I2C_SSTAT_RD_BUSY |
 413:.\Generated_Source\PSoC5/I2C_INT.c ****                                                        I2C_SSTAT_RD_ERR_OVFL);
 414:.\Generated_Source\PSoC5/I2C_INT.c ****                     }
 415:.\Generated_Source\PSoC5/I2C_INT.c **** 
 416:.\Generated_Source\PSoC5/I2C_INT.c ****                     I2C_state = I2C_SM_SL_RD_DATA;
 417:.\Generated_Source\PSoC5/I2C_INT.c ****                 }
 418:.\Generated_Source\PSoC5/I2C_INT.c ****                 else  /* Write transaction: receive 1st byte */
 419:.\Generated_Source\PSoC5/I2C_INT.c ****                 {
 420:.\Generated_Source\PSoC5/I2C_INT.c ****                     I2C_ACK_AND_RECEIVE;
 421:.\Generated_Source\PSoC5/I2C_INT.c ****                     I2C_state = I2C_SM_SL_WR_DATA;
 422:.\Generated_Source\PSoC5/I2C_INT.c **** 
 423:.\Generated_Source\PSoC5/I2C_INT.c ****                     I2C_slStatus |= I2C_SSTAT_WR_BUSY;
 424:.\Generated_Source\PSoC5/I2C_INT.c ****                     I2C_ENABLE_INT_ON_STOP;
 425:.\Generated_Source\PSoC5/I2C_INT.c ****                 }
 426:.\Generated_Source\PSoC5/I2C_INT.c **** 
 427:.\Generated_Source\PSoC5/I2C_INT.c ****             #endif /* (I2C_SW_ADRR_DECODE) */
 428:.\Generated_Source\PSoC5/I2C_INT.c ****             }
 429:.\Generated_Source\PSoC5/I2C_INT.c ****             /* Data states */
 430:.\Generated_Source\PSoC5/I2C_INT.c ****             /* Data master writes into slave */
 431:.\Generated_Source\PSoC5/I2C_INT.c ****             else if(I2C_state == I2C_SM_SL_WR_DATA)
 432:.\Generated_Source\PSoC5/I2C_INT.c ****             {
 433:.\Generated_Source\PSoC5/I2C_INT.c ****                 if(I2C_slWrBufIndex < I2C_slWrBufSize)
 434:.\Generated_Source\PSoC5/I2C_INT.c ****                 {
 435:.\Generated_Source\PSoC5/I2C_INT.c ****                     tmp8 = I2C_DATA_REG;
 436:.\Generated_Source\PSoC5/I2C_INT.c ****                     I2C_ACK_AND_RECEIVE;
 437:.\Generated_Source\PSoC5/I2C_INT.c ****                     I2C_slWrBufPtr[I2C_slWrBufIndex] = tmp8;
 438:.\Generated_Source\PSoC5/I2C_INT.c ****                     I2C_slWrBufIndex++;
 439:.\Generated_Source\PSoC5/I2C_INT.c ****                 }
 440:.\Generated_Source\PSoC5/I2C_INT.c ****                 else  /* of array: complete write, send NACK */
 441:.\Generated_Source\PSoC5/I2C_INT.c ****                 {
 442:.\Generated_Source\PSoC5/I2C_INT.c ****                     I2C_NAK_AND_RECEIVE;
 443:.\Generated_Source\PSoC5/I2C_INT.c **** 
 444:.\Generated_Source\PSoC5/I2C_INT.c ****                     I2C_slStatus |= I2C_SSTAT_WR_ERR_OVFL;
 445:.\Generated_Source\PSoC5/I2C_INT.c ****                 }
ARM GAS  C:\Users\Eih3\AppData\Local\Temp\cc1gG7hm.s 			page 15


 446:.\Generated_Source\PSoC5/I2C_INT.c ****             }
 447:.\Generated_Source\PSoC5/I2C_INT.c ****             /* Data master reads from slave */
 448:.\Generated_Source\PSoC5/I2C_INT.c ****             else if(I2C_state == I2C_SM_SL_RD_DATA)
 449:.\Generated_Source\PSoC5/I2C_INT.c ****             {
 450:.\Generated_Source\PSoC5/I2C_INT.c ****                 if(I2C_CHECK_DATA_ACK(tmpCsr))
 451:.\Generated_Source\PSoC5/I2C_INT.c ****                 {
 452:.\Generated_Source\PSoC5/I2C_INT.c ****                     if(I2C_slRdBufIndex < I2C_slRdBufSize)
 453:.\Generated_Source\PSoC5/I2C_INT.c ****                     {
 454:.\Generated_Source\PSoC5/I2C_INT.c ****                          /* Get data from array */
 455:.\Generated_Source\PSoC5/I2C_INT.c ****                         I2C_DATA_REG = I2C_slRdBufPtr[I2C_slRdBufIndex];
 456:.\Generated_Source\PSoC5/I2C_INT.c ****                         I2C_TRANSMIT_DATA;
 457:.\Generated_Source\PSoC5/I2C_INT.c ****                         I2C_slRdBufIndex++;
 458:.\Generated_Source\PSoC5/I2C_INT.c ****                     }
 459:.\Generated_Source\PSoC5/I2C_INT.c ****                     else   /* Overflow: provide 0xFF on bus */
 460:.\Generated_Source\PSoC5/I2C_INT.c ****                     {
 461:.\Generated_Source\PSoC5/I2C_INT.c ****                         I2C_DATA_REG = I2C_OVERFLOW_RETURN;
 462:.\Generated_Source\PSoC5/I2C_INT.c ****                         I2C_TRANSMIT_DATA;
 463:.\Generated_Source\PSoC5/I2C_INT.c **** 
 464:.\Generated_Source\PSoC5/I2C_INT.c ****                         I2C_slStatus |= I2C_SSTAT_RD_ERR_OVFL;
 465:.\Generated_Source\PSoC5/I2C_INT.c ****                     }
 466:.\Generated_Source\PSoC5/I2C_INT.c ****                 }
 467:.\Generated_Source\PSoC5/I2C_INT.c ****                 else  /* Last byte was NACKed: read complete */
 468:.\Generated_Source\PSoC5/I2C_INT.c ****                 {
 469:.\Generated_Source\PSoC5/I2C_INT.c ****                     /* Only NACK appears on bus */
 470:.\Generated_Source\PSoC5/I2C_INT.c ****                     I2C_DATA_REG = I2C_OVERFLOW_RETURN;
 471:.\Generated_Source\PSoC5/I2C_INT.c ****                     I2C_NAK_AND_TRANSMIT;
 472:.\Generated_Source\PSoC5/I2C_INT.c **** 
 473:.\Generated_Source\PSoC5/I2C_INT.c ****                     I2C_slStatus &= ((uint8) ~I2C_SSTAT_RD_BUSY);
 474:.\Generated_Source\PSoC5/I2C_INT.c ****                     I2C_slStatus |= ((uint8)  I2C_SSTAT_RD_CMPLT);
 475:.\Generated_Source\PSoC5/I2C_INT.c **** 
 476:.\Generated_Source\PSoC5/I2C_INT.c ****                     I2C_state = I2C_SM_IDLE;
 477:.\Generated_Source\PSoC5/I2C_INT.c ****                 }
 478:.\Generated_Source\PSoC5/I2C_INT.c ****             }
 479:.\Generated_Source\PSoC5/I2C_INT.c ****             else
 480:.\Generated_Source\PSoC5/I2C_INT.c ****             {
 481:.\Generated_Source\PSoC5/I2C_INT.c ****             #if(I2C_TIMEOUT_ENABLED)
 482:.\Generated_Source\PSoC5/I2C_INT.c ****                 /* Exit interrupt to take chance for timeout timer to handle this case */
 483:.\Generated_Source\PSoC5/I2C_INT.c ****                 I2C_DisableInt();
 484:.\Generated_Source\PSoC5/I2C_INT.c ****                 I2C_ClearPendingInt();
 485:.\Generated_Source\PSoC5/I2C_INT.c ****             #else
 486:.\Generated_Source\PSoC5/I2C_INT.c ****                 /* Block execution flow: unexpected condition */
 487:.\Generated_Source\PSoC5/I2C_INT.c ****                 CYASSERT(0u != 0u);
 488:.\Generated_Source\PSoC5/I2C_INT.c ****             #endif /* (I2C_TIMEOUT_ENABLED) */
 489:.\Generated_Source\PSoC5/I2C_INT.c ****             }
 490:.\Generated_Source\PSoC5/I2C_INT.c ****         }
 491:.\Generated_Source\PSoC5/I2C_INT.c ****     #endif /* (I2C_MODE_SLAVE_ENABLED) */
 492:.\Generated_Source\PSoC5/I2C_INT.c ****     }
 493:.\Generated_Source\PSoC5/I2C_INT.c ****     else
 494:.\Generated_Source\PSoC5/I2C_INT.c ****     {
 495:.\Generated_Source\PSoC5/I2C_INT.c ****         /* The FSM skips master and slave processing: return to IDLE */
 496:.\Generated_Source\PSoC5/I2C_INT.c ****         I2C_state = I2C_SM_IDLE;
 348              		.loc 1 496 0
 349 01e6 5CBF     		itt	pl
 350 01e8 1023     		movpl	r3, #16
 351 01ea 0370     		strbpl	r3, [r0]
 352              	.L1:
 353 01ec 70BD     		pop	{r4, r5, r6, pc}
ARM GAS  C:\Users\Eih3\AppData\Local\Temp\cc1gG7hm.s 			page 16


 354              	.L38:
 355 01ee 00BF     		.align	2
 356              	.L37:
 357 01f0 00000000 		.word	I2C_state
 358 01f4 D7490040 		.word	1073760727
 359 01f8 00000000 		.word	I2C_mstrWrBufSize
 360 01fc 00000000 		.word	I2C_mstrWrBufPtr
 361 0200 D8490040 		.word	1073760728
 362 0204 00000000 		.word	I2C_mstrWrBufIndex
 363 0208 00000000 		.word	I2C_mstrControl
 364 020c 00000000 		.word	I2C_mstrStatus
 365 0210 80E100E0 		.word	-536813184
 366 0214 D6490040 		.word	1073760726
 367 0218 00000000 		.word	I2C_mstrRdBufIndex
 368 021c 00000000 		.word	I2C_mstrRdBufPtr
 369 0220 00000000 		.word	I2C_mstrRdBufSize
 370              		.cfi_endproc
 371              	.LFE0:
 372              		.size	I2C_ISR, .-I2C_ISR
 373              		.text
 374              	.Letext0:
 375              		.file 2 ".\\Generated_Source\\PSoC5\\cytypes.h"
 376              		.file 3 ".\\Generated_Source\\PSoC5\\I2C_PVT.h"
 377              		.section	.debug_info,"",%progbits
 378              	.Ldebug_info0:
 379 0000 4A010000 		.4byte	0x14a
 380 0004 0400     		.2byte	0x4
 381 0006 00000000 		.4byte	.Ldebug_abbrev0
 382 000a 04       		.byte	0x4
 383 000b 01       		.uleb128 0x1
 384 000c 41000000 		.4byte	.LASF26
 385 0010 01       		.byte	0x1
 386 0011 0D000000 		.4byte	.LASF27
 387 0015 30010000 		.4byte	.LASF28
 388 0019 00000000 		.4byte	.Ldebug_ranges0+0
 389 001d 00000000 		.4byte	0
 390 0021 00000000 		.4byte	.Ldebug_line0
 391 0025 02       		.uleb128 0x2
 392 0026 01       		.byte	0x1
 393 0027 06       		.byte	0x6
 394 0028 E9000000 		.4byte	.LASF0
 395 002c 02       		.uleb128 0x2
 396 002d 01       		.byte	0x1
 397 002e 08       		.byte	0x8
 398 002f F5000000 		.4byte	.LASF1
 399 0033 02       		.uleb128 0x2
 400 0034 02       		.byte	0x2
 401 0035 05       		.byte	0x5
 402 0036 CA010000 		.4byte	.LASF2
 403 003a 02       		.uleb128 0x2
 404 003b 02       		.byte	0x2
 405 003c 07       		.byte	0x7
 406 003d BD000000 		.4byte	.LASF3
 407 0041 02       		.uleb128 0x2
 408 0042 04       		.byte	0x4
 409 0043 05       		.byte	0x5
 410 0044 FC010000 		.4byte	.LASF4
ARM GAS  C:\Users\Eih3\AppData\Local\Temp\cc1gG7hm.s 			page 17


 411 0048 02       		.uleb128 0x2
 412 0049 04       		.byte	0x4
 413 004a 07       		.byte	0x7
 414 004b 18010000 		.4byte	.LASF5
 415 004f 02       		.uleb128 0x2
 416 0050 08       		.byte	0x8
 417 0051 05       		.byte	0x5
 418 0052 B7010000 		.4byte	.LASF6
 419 0056 02       		.uleb128 0x2
 420 0057 08       		.byte	0x8
 421 0058 07       		.byte	0x7
 422 0059 97010000 		.4byte	.LASF7
 423 005d 03       		.uleb128 0x3
 424 005e 04       		.byte	0x4
 425 005f 05       		.byte	0x5
 426 0060 696E7400 		.ascii	"int\000"
 427 0064 02       		.uleb128 0x2
 428 0065 04       		.byte	0x4
 429 0066 07       		.byte	0x7
 430 0067 8A010000 		.4byte	.LASF8
 431 006b 04       		.uleb128 0x4
 432 006c 2A010000 		.4byte	.LASF9
 433 0070 02       		.byte	0x2
 434 0071 A1       		.byte	0xa1
 435 0072 2C000000 		.4byte	0x2c
 436 0076 04       		.uleb128 0x4
 437 0077 71010000 		.4byte	.LASF10
 438 007b 02       		.byte	0x2
 439 007c A3       		.byte	0xa3
 440 007d 48000000 		.4byte	0x48
 441 0081 02       		.uleb128 0x2
 442 0082 04       		.byte	0x4
 443 0083 04       		.byte	0x4
 444 0084 E3000000 		.4byte	.LASF11
 445 0088 02       		.uleb128 0x2
 446 0089 08       		.byte	0x8
 447 008a 04       		.byte	0x4
 448 008b 6A010000 		.4byte	.LASF12
 449 008f 02       		.uleb128 0x2
 450 0090 01       		.byte	0x1
 451 0091 08       		.byte	0x8
 452 0092 C5010000 		.4byte	.LASF13
 453 0096 05       		.uleb128 0x5
 454 0097 03010000 		.4byte	.LASF14
 455 009b 02       		.byte	0x2
 456 009c 4B01     		.2byte	0x14b
 457 009e A2000000 		.4byte	0xa2
 458 00a2 06       		.uleb128 0x6
 459 00a3 6B000000 		.4byte	0x6b
 460 00a7 05       		.uleb128 0x5
 461 00a8 07000000 		.4byte	.LASF15
 462 00ac 02       		.byte	0x2
 463 00ad 4D01     		.2byte	0x14d
 464 00af B3000000 		.4byte	0xb3
 465 00b3 06       		.uleb128 0x6
 466 00b4 76000000 		.4byte	0x76
 467 00b8 02       		.uleb128 0x2
ARM GAS  C:\Users\Eih3\AppData\Local\Temp\cc1gG7hm.s 			page 18


 468 00b9 04       		.byte	0x4
 469 00ba 07       		.byte	0x7
 470 00bb AE010000 		.4byte	.LASF16
 471 00bf 07       		.uleb128 0x7
 472 00c0 D4010000 		.4byte	.LASF29
 473 00c4 01       		.byte	0x1
 474 00c5 2D       		.byte	0x2d
 475 00c6 00000000 		.4byte	.LFB0
 476 00ca 24020000 		.4byte	.LFE0-.LFB0
 477 00ce 01       		.uleb128 0x1
 478 00cf 9C       		.byte	0x9c
 479 00d0 E4000000 		.4byte	0xe4
 480 00d4 08       		.uleb128 0x8
 481 00d5 00000000 		.4byte	.LASF30
 482 00d9 01       		.byte	0x1
 483 00da 33       		.byte	0x33
 484 00db 6B000000 		.4byte	0x6b
 485 00df 00000000 		.4byte	.LLST0
 486 00e3 00       		.byte	0
 487 00e4 09       		.uleb128 0x9
 488 00e5 05020000 		.4byte	.LASF17
 489 00e9 03       		.byte	0x3
 490 00ea 23       		.byte	0x23
 491 00eb A2000000 		.4byte	0xa2
 492 00ef 09       		.uleb128 0x9
 493 00f0 DC010000 		.4byte	.LASF18
 494 00f4 03       		.byte	0x3
 495 00f5 27       		.byte	0x27
 496 00f6 A2000000 		.4byte	0xa2
 497 00fa 09       		.uleb128 0x9
 498 00fb 08010000 		.4byte	.LASF19
 499 00ff 03       		.byte	0x3
 500 0100 28       		.byte	0x28
 501 0101 A2000000 		.4byte	0xa2
 502 0105 09       		.uleb128 0x9
 503 0106 EB010000 		.4byte	.LASF20
 504 010a 03       		.byte	0x3
 505 010b 2B       		.byte	0x2b
 506 010c 10010000 		.4byte	0x110
 507 0110 0A       		.uleb128 0xa
 508 0111 04       		.byte	0x4
 509 0112 A2000000 		.4byte	0xa2
 510 0116 09       		.uleb128 0x9
 511 0117 78010000 		.4byte	.LASF21
 512 011b 03       		.byte	0x3
 513 011c 2C       		.byte	0x2c
 514 011d A2000000 		.4byte	0xa2
 515 0121 09       		.uleb128 0x9
 516 0122 D0000000 		.4byte	.LASF22
 517 0126 03       		.byte	0x3
 518 0127 2D       		.byte	0x2d
 519 0128 A2000000 		.4byte	0xa2
 520 012c 09       		.uleb128 0x9
 521 012d 30000000 		.4byte	.LASF23
 522 0131 03       		.byte	0x3
 523 0132 30       		.byte	0x30
 524 0133 10010000 		.4byte	0x110
ARM GAS  C:\Users\Eih3\AppData\Local\Temp\cc1gG7hm.s 			page 19


 525 0137 09       		.uleb128 0x9
 526 0138 22020000 		.4byte	.LASF24
 527 013c 03       		.byte	0x3
 528 013d 31       		.byte	0x31
 529 013e A2000000 		.4byte	0xa2
 530 0142 09       		.uleb128 0x9
 531 0143 0F020000 		.4byte	.LASF25
 532 0147 03       		.byte	0x3
 533 0148 32       		.byte	0x32
 534 0149 A2000000 		.4byte	0xa2
 535 014d 00       		.byte	0
 536              		.section	.debug_abbrev,"",%progbits
 537              	.Ldebug_abbrev0:
 538 0000 01       		.uleb128 0x1
 539 0001 11       		.uleb128 0x11
 540 0002 01       		.byte	0x1
 541 0003 25       		.uleb128 0x25
 542 0004 0E       		.uleb128 0xe
 543 0005 13       		.uleb128 0x13
 544 0006 0B       		.uleb128 0xb
 545 0007 03       		.uleb128 0x3
 546 0008 0E       		.uleb128 0xe
 547 0009 1B       		.uleb128 0x1b
 548 000a 0E       		.uleb128 0xe
 549 000b 55       		.uleb128 0x55
 550 000c 17       		.uleb128 0x17
 551 000d 11       		.uleb128 0x11
 552 000e 01       		.uleb128 0x1
 553 000f 10       		.uleb128 0x10
 554 0010 17       		.uleb128 0x17
 555 0011 00       		.byte	0
 556 0012 00       		.byte	0
 557 0013 02       		.uleb128 0x2
 558 0014 24       		.uleb128 0x24
 559 0015 00       		.byte	0
 560 0016 0B       		.uleb128 0xb
 561 0017 0B       		.uleb128 0xb
 562 0018 3E       		.uleb128 0x3e
 563 0019 0B       		.uleb128 0xb
 564 001a 03       		.uleb128 0x3
 565 001b 0E       		.uleb128 0xe
 566 001c 00       		.byte	0
 567 001d 00       		.byte	0
 568 001e 03       		.uleb128 0x3
 569 001f 24       		.uleb128 0x24
 570 0020 00       		.byte	0
 571 0021 0B       		.uleb128 0xb
 572 0022 0B       		.uleb128 0xb
 573 0023 3E       		.uleb128 0x3e
 574 0024 0B       		.uleb128 0xb
 575 0025 03       		.uleb128 0x3
 576 0026 08       		.uleb128 0x8
 577 0027 00       		.byte	0
 578 0028 00       		.byte	0
 579 0029 04       		.uleb128 0x4
 580 002a 16       		.uleb128 0x16
 581 002b 00       		.byte	0
ARM GAS  C:\Users\Eih3\AppData\Local\Temp\cc1gG7hm.s 			page 20


 582 002c 03       		.uleb128 0x3
 583 002d 0E       		.uleb128 0xe
 584 002e 3A       		.uleb128 0x3a
 585 002f 0B       		.uleb128 0xb
 586 0030 3B       		.uleb128 0x3b
 587 0031 0B       		.uleb128 0xb
 588 0032 49       		.uleb128 0x49
 589 0033 13       		.uleb128 0x13
 590 0034 00       		.byte	0
 591 0035 00       		.byte	0
 592 0036 05       		.uleb128 0x5
 593 0037 16       		.uleb128 0x16
 594 0038 00       		.byte	0
 595 0039 03       		.uleb128 0x3
 596 003a 0E       		.uleb128 0xe
 597 003b 3A       		.uleb128 0x3a
 598 003c 0B       		.uleb128 0xb
 599 003d 3B       		.uleb128 0x3b
 600 003e 05       		.uleb128 0x5
 601 003f 49       		.uleb128 0x49
 602 0040 13       		.uleb128 0x13
 603 0041 00       		.byte	0
 604 0042 00       		.byte	0
 605 0043 06       		.uleb128 0x6
 606 0044 35       		.uleb128 0x35
 607 0045 00       		.byte	0
 608 0046 49       		.uleb128 0x49
 609 0047 13       		.uleb128 0x13
 610 0048 00       		.byte	0
 611 0049 00       		.byte	0
 612 004a 07       		.uleb128 0x7
 613 004b 2E       		.uleb128 0x2e
 614 004c 01       		.byte	0x1
 615 004d 3F       		.uleb128 0x3f
 616 004e 19       		.uleb128 0x19
 617 004f 03       		.uleb128 0x3
 618 0050 0E       		.uleb128 0xe
 619 0051 3A       		.uleb128 0x3a
 620 0052 0B       		.uleb128 0xb
 621 0053 3B       		.uleb128 0x3b
 622 0054 0B       		.uleb128 0xb
 623 0055 27       		.uleb128 0x27
 624 0056 19       		.uleb128 0x19
 625 0057 11       		.uleb128 0x11
 626 0058 01       		.uleb128 0x1
 627 0059 12       		.uleb128 0x12
 628 005a 06       		.uleb128 0x6
 629 005b 40       		.uleb128 0x40
 630 005c 18       		.uleb128 0x18
 631 005d 9742     		.uleb128 0x2117
 632 005f 19       		.uleb128 0x19
 633 0060 01       		.uleb128 0x1
 634 0061 13       		.uleb128 0x13
 635 0062 00       		.byte	0
 636 0063 00       		.byte	0
 637 0064 08       		.uleb128 0x8
 638 0065 34       		.uleb128 0x34
ARM GAS  C:\Users\Eih3\AppData\Local\Temp\cc1gG7hm.s 			page 21


 639 0066 00       		.byte	0
 640 0067 03       		.uleb128 0x3
 641 0068 0E       		.uleb128 0xe
 642 0069 3A       		.uleb128 0x3a
 643 006a 0B       		.uleb128 0xb
 644 006b 3B       		.uleb128 0x3b
 645 006c 0B       		.uleb128 0xb
 646 006d 49       		.uleb128 0x49
 647 006e 13       		.uleb128 0x13
 648 006f 02       		.uleb128 0x2
 649 0070 17       		.uleb128 0x17
 650 0071 00       		.byte	0
 651 0072 00       		.byte	0
 652 0073 09       		.uleb128 0x9
 653 0074 34       		.uleb128 0x34
 654 0075 00       		.byte	0
 655 0076 03       		.uleb128 0x3
 656 0077 0E       		.uleb128 0xe
 657 0078 3A       		.uleb128 0x3a
 658 0079 0B       		.uleb128 0xb
 659 007a 3B       		.uleb128 0x3b
 660 007b 0B       		.uleb128 0xb
 661 007c 49       		.uleb128 0x49
 662 007d 13       		.uleb128 0x13
 663 007e 3F       		.uleb128 0x3f
 664 007f 19       		.uleb128 0x19
 665 0080 3C       		.uleb128 0x3c
 666 0081 19       		.uleb128 0x19
 667 0082 00       		.byte	0
 668 0083 00       		.byte	0
 669 0084 0A       		.uleb128 0xa
 670 0085 0F       		.uleb128 0xf
 671 0086 00       		.byte	0
 672 0087 0B       		.uleb128 0xb
 673 0088 0B       		.uleb128 0xb
 674 0089 49       		.uleb128 0x49
 675 008a 13       		.uleb128 0x13
 676 008b 00       		.byte	0
 677 008c 00       		.byte	0
 678 008d 00       		.byte	0
 679              		.section	.debug_loc,"",%progbits
 680              	.Ldebug_loc0:
 681              	.LLST0:
 682 0000 0C000000 		.4byte	.LVL0
 683 0004 3A000000 		.4byte	.LVL1
 684 0008 0100     		.2byte	0x1
 685 000a 53       		.byte	0x53
 686 000b 3A000000 		.4byte	.LVL1
 687 000f D8000000 		.4byte	.LVL2
 688 0013 0100     		.2byte	0x1
 689 0015 50       		.byte	0x50
 690 0016 D8000000 		.4byte	.LVL2
 691 001a B8010000 		.4byte	.LVL3
 692 001e 0100     		.2byte	0x1
 693 0020 53       		.byte	0x53
 694 0021 B8010000 		.4byte	.LVL3
 695 0025 BA010000 		.4byte	.LVL4
ARM GAS  C:\Users\Eih3\AppData\Local\Temp\cc1gG7hm.s 			page 22


 696 0029 0100     		.2byte	0x1
 697 002b 50       		.byte	0x50
 698 002c BA010000 		.4byte	.LVL4
 699 0030 C0010000 		.4byte	.LVL5
 700 0034 0100     		.2byte	0x1
 701 0036 53       		.byte	0x53
 702 0037 E2010000 		.4byte	.LVL6
 703 003b E4010000 		.4byte	.LVL7
 704 003f 0100     		.2byte	0x1
 705 0041 53       		.byte	0x53
 706 0042 00000000 		.4byte	0
 707 0046 00000000 		.4byte	0
 708              		.section	.debug_aranges,"",%progbits
 709 0000 1C000000 		.4byte	0x1c
 710 0004 0200     		.2byte	0x2
 711 0006 00000000 		.4byte	.Ldebug_info0
 712 000a 04       		.byte	0x4
 713 000b 00       		.byte	0
 714 000c 0000     		.2byte	0
 715 000e 0000     		.2byte	0
 716 0010 00000000 		.4byte	.LFB0
 717 0014 24020000 		.4byte	.LFE0-.LFB0
 718 0018 00000000 		.4byte	0
 719 001c 00000000 		.4byte	0
 720              		.section	.debug_ranges,"",%progbits
 721              	.Ldebug_ranges0:
 722 0000 00000000 		.4byte	.LFB0
 723 0004 24020000 		.4byte	.LFE0
 724 0008 00000000 		.4byte	0
 725 000c 00000000 		.4byte	0
 726              		.section	.debug_line,"",%progbits
 727              	.Ldebug_line0:
 728 0000 C2000000 		.section	.debug_str,"MS",%progbits,1
 728      02005300 
 728      00000201 
 728      FB0E0D00 
 728      01010101 
 729              	.LASF30:
 730 0000 746D7043 		.ascii	"tmpCsr\000"
 730      737200
 731              	.LASF15:
 732 0007 72656733 		.ascii	"reg32\000"
 732      3200
 733              	.LASF27:
 734 000d 2E5C4765 		.ascii	".\\Generated_Source\\PSoC5\\I2C_INT.c\000"
 734      6E657261 
 734      7465645F 
 734      536F7572 
 734      63655C50 
 735              	.LASF23:
 736 0030 4932435F 		.ascii	"I2C_mstrWrBufPtr\000"
 736      6D737472 
 736      57724275 
 736      66507472 
 736      00
 737              	.LASF26:
 738 0041 474E5520 		.ascii	"GNU C 4.8.4 20140526 (release) [ARM/embedded-4_8-br"
ARM GAS  C:\Users\Eih3\AppData\Local\Temp\cc1gG7hm.s 			page 23


 738      4320342E 
 738      382E3420 
 738      32303134 
 738      30353236 
 739 0074 616E6368 		.ascii	"anch revision 211358] -mcpu=cortex-m3 -mthumb -g -O"
 739      20726576 
 739      6973696F 
 739      6E203231 
 739      31333538 
 740 00a7 73202D66 		.ascii	"s -ffunction-sections\000"
 740      66756E63 
 740      74696F6E 
 740      2D736563 
 740      74696F6E 
 741              	.LASF3:
 742 00bd 73686F72 		.ascii	"short unsigned int\000"
 742      7420756E 
 742      7369676E 
 742      65642069 
 742      6E7400
 743              	.LASF22:
 744 00d0 4932435F 		.ascii	"I2C_mstrRdBufIndex\000"
 744      6D737472 
 744      52644275 
 744      66496E64 
 744      657800
 745              	.LASF11:
 746 00e3 666C6F61 		.ascii	"float\000"
 746      7400
 747              	.LASF0:
 748 00e9 7369676E 		.ascii	"signed char\000"
 748      65642063 
 748      68617200 
 749              	.LASF1:
 750 00f5 756E7369 		.ascii	"unsigned char\000"
 750      676E6564 
 750      20636861 
 750      7200
 751              	.LASF14:
 752 0103 72656738 		.ascii	"reg8\000"
 752      00
 753              	.LASF19:
 754 0108 4932435F 		.ascii	"I2C_mstrControl\000"
 754      6D737472 
 754      436F6E74 
 754      726F6C00 
 755              	.LASF5:
 756 0118 6C6F6E67 		.ascii	"long unsigned int\000"
 756      20756E73 
 756      69676E65 
 756      6420696E 
 756      7400
 757              	.LASF9:
 758 012a 75696E74 		.ascii	"uint8\000"
 758      3800
 759              	.LASF28:
 760 0130 443A5C45 		.ascii	"D:\\Eih3Cloud\\Projet Programme\\Module HF\\5\\Modu"
ARM GAS  C:\Users\Eih3\AppData\Local\Temp\cc1gG7hm.s 			page 24


 760      69683343 
 760      6C6F7564 
 760      5C50726F 
 760      6A657420 
 761 015e 6C652048 		.ascii	"le HF.cydsn\000"
 761      462E6379 
 761      64736E00 
 762              	.LASF12:
 763 016a 646F7562 		.ascii	"double\000"
 763      6C6500
 764              	.LASF10:
 765 0171 75696E74 		.ascii	"uint32\000"
 765      333200
 766              	.LASF21:
 767 0178 4932435F 		.ascii	"I2C_mstrRdBufSize\000"
 767      6D737472 
 767      52644275 
 767      6653697A 
 767      6500
 768              	.LASF8:
 769 018a 756E7369 		.ascii	"unsigned int\000"
 769      676E6564 
 769      20696E74 
 769      00
 770              	.LASF7:
 771 0197 6C6F6E67 		.ascii	"long long unsigned int\000"
 771      206C6F6E 
 771      6720756E 
 771      7369676E 
 771      65642069 
 772              	.LASF16:
 773 01ae 73697A65 		.ascii	"sizetype\000"
 773      74797065 
 773      00
 774              	.LASF6:
 775 01b7 6C6F6E67 		.ascii	"long long int\000"
 775      206C6F6E 
 775      6720696E 
 775      7400
 776              	.LASF13:
 777 01c5 63686172 		.ascii	"char\000"
 777      00
 778              	.LASF2:
 779 01ca 73686F72 		.ascii	"short int\000"
 779      7420696E 
 779      7400
 780              	.LASF29:
 781 01d4 4932435F 		.ascii	"I2C_ISR\000"
 781      49535200 
 782              	.LASF18:
 783 01dc 4932435F 		.ascii	"I2C_mstrStatus\000"
 783      6D737472 
 783      53746174 
 783      757300
 784              	.LASF20:
 785 01eb 4932435F 		.ascii	"I2C_mstrRdBufPtr\000"
 785      6D737472 
ARM GAS  C:\Users\Eih3\AppData\Local\Temp\cc1gG7hm.s 			page 25


 785      52644275 
 785      66507472 
 785      00
 786              	.LASF4:
 787 01fc 6C6F6E67 		.ascii	"long int\000"
 787      20696E74 
 787      00
 788              	.LASF17:
 789 0205 4932435F 		.ascii	"I2C_state\000"
 789      73746174 
 789      6500
 790              	.LASF25:
 791 020f 4932435F 		.ascii	"I2C_mstrWrBufIndex\000"
 791      6D737472 
 791      57724275 
 791      66496E64 
 791      657800
 792              	.LASF24:
 793 0222 4932435F 		.ascii	"I2C_mstrWrBufSize\000"
 793      6D737472 
 793      57724275 
 793      6653697A 
 793      6500
 794              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 4.8.4 20140526 (release) [ARM/embedded-4_8-br
